<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>








<script>
// let func = str=>str.split('')
//   .reduce((accum, elem)=>{accum.at(-1) !== elem ? [...accum, elem] : accum},[]).join('')
//
//
// func('qqqqqqwwwwerer')

let s = 'Если объект недоступен, то алгоритм помечает его, после чего убирает. Корневые объекты при этом никогда не уничтожаются. Проблема циклических ссылок здесь не актуальна — алгоритм позволяет понять, что ни dad, ни son уже недоступны, поэтому их можно «вымести», а память — вернуть системе.\n' +
        '\n' +
        'С 2012 года абсолютно все браузеры оснащаются сборщиками мусора, которые работают именно по методу mark and sweep.\n' +
        '\n' +
        'Не обошлось без недостатков и здесь\n' +
        '\n' +
        '\n' +
        'Можно было бы подумать, что все отлично, и теперь можно забыть об управлении памятью, поручив все алгоритму. Но это не совсем так.\n' +
        '\n' +
        'Использование большого объема памяти\n' +
        '\n' +
        'Из-за того, что алгоритмы не умеют определять, когда именно память становится ненужной, приложения на JavaScript могут использовать больший объем памяти, чем нужно. И лишь сборщик может решить, освобождать или нет выделенную память.\n' +
        '\n' +
        'Лучше JavaScript с управлением памятью справляются низкоуровневые языки. Но и здесь есть свои недостатки, что нужно иметь в виду. В частности, JS не даёт инструментов управления памятью, в отличие от низкоуровневые языков, в которых программист «вручную» занимается выделением и высвобождением памяти.\n' +
        '\n' +
        'Производительность\n' +
        '\n' +
        'Память не очищается каждый новый момент времени. Освобождение выполняется с определенной периодичностью. Но разработчики не могут знать, когда именно запускаются эти процессы.\n' +
        '\n' +
        'Поэтому в некоторых случаях сборка мусора может негативно отражаться на производительности, поскольку алгоритму для работы нужны определенные ресурсы. Правда, ситуация редко становится прямо совсем уж неуправляемой. Чаще всего последствия этого микроскопические.\n' +
        '\n' +
        'Утечки памяти'

let coderVoiny = str => str.split('')
        .reduce(function(acc, item) {
          return acc.at(-1) !== item ? [...acc, item] : acc}, [])
                .join('')



for(let i = 0; i <1000; i++){
  console.log(coderVoiny(s));
}


  // время 23.15 мс


</script>
</body>
</html>