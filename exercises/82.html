<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Документ</title>
<style>


</style>
</head>
<body>





<script>

  let a = 'Если объект недоступен, то алгоритм помечает его, после чего убирает. Корневые объекты при этом никогда не уничтожаются. Проблема циклических ссылок здесь не актуальна — алгоритм позволяет понять, что ни dad, ни son уже недоступны, поэтому их можно «вымести», а память — вернуть системе.\n' +
		  '\n' +
		  'С 2012 года абсолютно все браузеры оснащаются сборщиками мусора, которые работают именно по методу mark and sweep.\n' +
		  '\n' +
		  'Не обошлось без недостатков и здесь\n' +
		  '\n' +
		  '\n' +
		  'Можно было бы подумать, что все отлично, и теперь можно забыть об управлении памятью, поручив все алгоритму. Но это не совсем так.\n' +
		  '\n' +
		  'Использование большого объема памяти\n' +
		  '\n' +
		  'Из-за того, что алгоритмы не умеют определять, когда именно память становится ненужной, приложения на JavaScript могут использовать больший объем памяти, чем нужно. И лишь сборщик может решить, освобождать или нет выделенную память.\n' +
		  '\n' +
		  'Лучше JavaScript с управлением памятью справляются низкоуровневые языки. Но и здесь есть свои недостатки, что нужно иметь в виду. В частности, JS не даёт инструментов управления памятью, в отличие от низкоуровневые языков, в которых программист «вручную» занимается выделением и высвобождением памяти.\n' +
		  '\n' +
		  'Производительность\n' +
		  '\n' +
		  'Память не очищается каждый новый момент времени. Освобождение выполняется с определенной периодичностью. Но разработчики не могут знать, когда именно запускаются эти процессы.\n' +
		  '\n' +
		  'Поэтому в некоторых случаях сборка мусора может негативно отражаться на производительности, поскольку алгоритму для работы нужны определенные ресурсы. Правда, ситуация редко становится прямо совсем уж неуправляемой. Чаще всего последствия этого микроскопические.\n' +
		  '\n' +
		  'Утечки памяти'

  function f(str) {
      if(str.length===0) return str;
      else {
        let res = str[0];
        let s = str[0]
        for(let i = 1; i<str.length; i++){
          if(s !== str[i]){
            res+=str[i]
            s=str[i]


          }
        }
        return res
      }

  }

  console.time()
  for(let i = 0; i <1000; i++){
	  console.log(f(a));
  }
  console.timeEnd()


	//100-153 мс, память 8-14 мб

</script>












</body>
</html>